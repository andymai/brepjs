mainBuild:
  name: brepjs_threaded.js
  bindings:
  - symbol: Message_ProgressRange
  - symbol: TColgp_Array1OfDir
  - symbol: TColgp_Array1OfPnt
  - symbol: TColgp_Array1OfPnt2d
  - symbol: TColgp_Array2OfPnt
  - symbol: TColStd_Array1OfBoolean
  - symbol: TColgp_Array1OfVec
  - symbol: TColStd_Array1OfInteger
  - symbol: TColStd_Array1OfReal
  - symbol: Poly_Array1OfTriangle
  - symbol: Standard_Transient
  - symbol: Precision
  - symbol: Interface_Static
  - symbol: Interface_TypedValue
  - symbol: MoniTool_TypedValue
  - symbol: Handle_StepData_StepModel
  - symbol: gp_XYZ
  - symbol: gp_XY
  - symbol: gp_Vec
  - symbol: gp_Pnt
  - symbol: gp_Dir
  - symbol: gp_Ax1
  - symbol: gp_Ax2
  - symbol: gp_Ax3
  - symbol: gp_Circ
  - symbol: gp_Elips
  - symbol: gp_Cylinder
  - symbol: gp_Sphere
  - symbol: gp_Trsf
  - symbol: gp_GTrsf
  - symbol: Geom2d_Line
  - symbol: Geom2d_Curve
  - symbol: Geom2d_OffsetCurve
  - symbol: Geom2d_BoundedCurve
  - symbol: Geom2d_TrimmedCurve
  - symbol: Geom2d_BezierCurve
  - symbol: Geom2d_BSplineCurve
  - symbol: Geom2d_Geometry
  - symbol: Geom2d_Ellipse
  - symbol: Geom2d_Circle
  - symbol: Geom2d_Conic
  - symbol: Geom_SphericalSurface
  - symbol: Geom_ElementarySurface
  - symbol: Handle_Geom2d_Geometry
  - symbol: Handle_Geom2d_Line
  - symbol: Handle_Geom2d_Curve
  - symbol: Handle_Geom2d_BoundedCurve
  - symbol: Handle_Geom2d_TrimmedCurve
  - symbol: Handle_Geom2d_Ellipse
  - symbol: Handle_Geom2d_Circle
  - symbol: Handle_Geom2d_BezierCurve
  - symbol: Handle_Geom2d_BSplineCurve
  - symbol: Handle_Geom_SphericalSurface
  - symbol: Handle_Geom_ElementarySurface
  - symbol: Handle_Geom_Geometry
  - symbol: gp_Vec2d
  - symbol: gp_Pnt2d
  - symbol: gp_Dir2d
  - symbol: gp_Ax2d
  - symbol: gp_Ax22d
  - symbol: gp_Circ2d
  - symbol: gp_Elips2d
  - symbol: GCE2d_Root
  - symbol: GCE2d_MakeSegment
  - symbol: GCE2d_MakeArcOfCircle
  - symbol: GCE2d_MakeArcOfEllipse
  - symbol: GCE2d_MakeCircle
  - symbol: GCE2d_MakeEllipse
  - symbol: GeomLib
  - symbol: gp_Trsf2d
  - symbol: gp_GTrsf2d
  - symbol: Bnd_Box2d
  - symbol: BndLib_Add2dCurve
  - symbol: Geom2dAPI_InterCurveCurve
  - symbol: Geom2dAPI_ProjectPointOnCurve
  - symbol: Geom2dAPI_PointsToBSpline
  - symbol: Geom2dAPI_ExtremaCurveCurve
  - symbol: Bnd_Box
  - symbol: Bnd_OBB
  - symbol: BRepBndLib
  - symbol: GeomAbs_CurveType
  - symbol: GeomAbs_SurfaceType
  - symbol: GeomAbs_Shape
  - symbol: GeomTools
  - symbol: Geom_Geometry
  - symbol: Geom_Curve
  - symbol: Geom_Surface
  - symbol: Geom_ElementarySurface
  - symbol: Geom_ConicalSurface
  - symbol: Geom_CylindricalSurface
  - symbol: Geom_BoundedSurface
  - symbol: Geom_BSplineSurface
  - symbol: Geom_BoundedCurve
  - symbol: Geom_TrimmedCurve
  - symbol: Geom_BezierCurve
  - symbol: Geom_BSplineCurve
  - symbol: GeomAPI_Interpolate
  - symbol: GeomAPI_PointsToBSpline
  - symbol: GeomAPI_PointsToBSplineSurface
  - symbol: GeomAPI_ProjectPointOnSurf
  - symbol: Handle_Geom_TrimmedCurve
  - symbol: Handle_Geom_Curve
  - symbol: Handle_Geom_Surface
  - symbol: Handle_Geom_BezierCurve
  - symbol: Handle_Geom_BSplineCurve
  - symbol: Handle_Geom_BSplineSurface
  - symbol: TopoDS
  - symbol: TopoDS_Edge
  - symbol: TopoDS_Face
  - symbol: TopoDS_Wire
  - symbol: TopoDS_Shell
  - symbol: TopoDS_Vertex
  - symbol: TopoDS_Solid
  - symbol: TopoDS_Compound
  - symbol: TopoDS_CompSolid
  - symbol: TopoDS_Shape
  - symbol: TopoDS_Builder
  - symbol: TopAbs_ShapeEnum
  - symbol: TopTools_ListOfShape
  - symbol: TopAbs_Orientation
  - symbol: TopLoc_Location
  - symbol: TopExp_Explorer
  - symbol: NCollection_BaseList
  - symbol: Poly_Connect
  - symbol: StdPrs_ToolTriangulatedShape
  - symbol: Poly_Triangle
  - symbol: Poly_Triangulation
  - symbol: Handle_Poly_Triangulation
  - symbol: Poly_PolygonOnTriangulation
  - symbol: Handle_Poly_PolygonOnTriangulation
  - symbol: BinTools
  - symbol: BRep_Tool
  - symbol: BRepLib
  - symbol: BRepTools
  - symbol: BRepGProp
  - symbol: BRepGProp_Face
  - symbol: GProp_GProps
  - symbol: GC_MakeArcOfCircle
  - symbol: GC_MakeArcOfEllipse
  - symbol: GC_Root
  - symbol: GCPnts_TangentialDeflection
  - symbol: BRepMesh_IncrementalMesh
  - symbol: BRepMesh_DiscretRoot
  - symbol: BRepAdaptor_Surface
  - symbol: BRepAdaptor_Curve
  - symbol: Adaptor3d_Curve
  - symbol: Adaptor3d_Surface
  - symbol: BRepAdaptor_CompCurve
  - symbol: Geom2dAdaptor_Curve
  - symbol: Adaptor2d_Curve2d
  - symbol: Handle_Adaptor2d_Curve2d
  - symbol: BRepAdaptor_Curve2d
  - symbol: Geom2dConvert_BSplineCurveToBezierCurve
  - symbol: Geom2dConvert_ApproxCurve
  - symbol: Geom2dConvert
  - symbol: Convert_ParameterisationType
  - symbol: GeomConvert
  - symbol: StlAPI_Writer
  - symbol: STEPControl_Writer
  - symbol: STEPControl_StepModelType
  - symbol: IFSelect_ReturnStatus
  - symbol: Handle_Law_Function
  - symbol: Law_Function
  - symbol: Law_Linear
  - symbol: Law_Composite
  - symbol: Law_Interpol
  - symbol: Law_BSpFunc
  - symbol: Law_S
  - symbol: BRepAlgoAPI_Algo
  - symbol: BRepAlgoAPI_BuilderAlgo
  - symbol: BRepAlgoAPI_BooleanOperation
  - symbol: BRepAlgoAPI_Cut
  - symbol: BRepAlgoAPI_Fuse
  - symbol: BOPAlgo_GlueEnum
  - symbol: BOPAlgo_Options
  - symbol: BRepAlgoAPI_Section
  - symbol: BRepAlgoAPI_Common
  - symbol: BRepExtrema_DistShapeShape
  - symbol: BRepBuilderAPI_ModifyShape
  - symbol: BRepBuilderAPI_MakeShape
  - symbol: BRepBuilderAPI_Command
  - symbol: BRepBuilderAPI_Transform
  - symbol: BRepBuilderAPI_MakeEdge
  - symbol: BRepBuilderAPI_MakeWire
  - symbol: BRepBuilderAPI_MakeFace
  - symbol: BRepBuilderAPI_MakeVertex
  - symbol: BRepBuilderAPI_MakeSolid
  - symbol: BRepBuilderAPI_TransitionMode
  - symbol: BRepBuilderAPI_Sewing
  - symbol: BRepBuilderAPI_WireError
  - symbol: BRepBuilderAPI_MakeShell
  - symbol: BRepPrimAPI_MakeOneAxis
  - symbol: BRepPrimAPI_MakeCylinder
  - symbol: BRepPrimAPI_MakeBox
  - symbol: BRepCheck_Analyzer
  - symbol: BRepPrimAPI_MakeSweep
  - symbol: BRepPrimAPI_MakePrism
  - symbol: BRepPrimAPI_MakeRevol
  - symbol: BRepPrimAPI_MakeSphere
  - symbol: BRepPrimAPI_MakeCone
  - symbol: BRepPrimAPI_MakeTorus
  - symbol: BRepPrimAPI_MakeRevolution
  - symbol: BRepOffsetAPI_ThruSections
  - symbol: BRepOffsetAPI_MakeThickSolid
  - symbol: BRepOffsetAPI_MakeOffset
  - symbol: BRepOffsetAPI_MakeOffsetShape
  - symbol: BRepOffsetAPI_MakePipe
  - symbol: BRepOffsetAPI_MakePipeShell
  - symbol: BRepOffsetAPI_MakeFilling
  - symbol: BRepOffset_Mode
  - symbol: BRepFilletAPI_LocalOperation
  - symbol: BRepFilletAPI_MakeFillet
  - symbol: BRepFilletAPI_MakeChamfer
  - symbol: BRepFeat_MakeDPrism
  - symbol: BRepFeat_Form
  - symbol: ChFi3d_FilletShape
  - symbol: ChFiDS_ChamfMode
  - symbol: GeomAbs_JoinType
  - symbol: BRepFill_TypeOfContact
  - symbol: Extrema_ExtAlgo
  - symbol: ShapeFix_Root
  - symbol: ShapeFix_Solid
  - symbol: ShapeFix_Face
  - symbol: ShapeFix_Wire
  - symbol: STEPControl_Reader
  - symbol: XSControl_Reader
  - symbol: StlAPI_Reader
  - symbol: ShapeUpgrade_UnifySameDomain
  - symbol: ShapeFix_EdgeConnect
  - symbol: StlAPI
  - symbol: HLRBRep_Algo
  - symbol: Handle_HLRBRep_Algo
  - symbol: HLRBRep_InternalAlgo
  - symbol: HLRAlgo_Projector
  - symbol: HLRBRep_HLRToShape
  - symbol: CDM_Document
  - symbol: TDF_Attribute
  - symbol: TDataStd_GenericEmpty
  - symbol: TDocStd_Document
  - symbol: TDataStd_GenericExtString
  - symbol: XCAFDoc_LengthUnit
  - symbol: Handle_TDocStd_Document
  - symbol: TCollection_ExtendedString
  - symbol: XCAFDoc_DocumentTool
  - symbol: XCAFDoc_ShapeTool
  - symbol: Handle_XCAFDoc_ShapeTool
  - symbol: XCAFDoc_ColorTool
  - symbol: Handle_XCAFDoc_ColorTool
  - symbol: TDF_Label
  - symbol: TDataStd_Name
  - symbol: Handle_TDataStd_Name
  - symbol: Quantity_ColorRGBA
  - symbol: Quantity_Color
  - symbol: XCAFDoc_ColorType
  - symbol: XSControl_WorkSession
  - symbol: Handle_XSControl_WorkSession
  - symbol: STEPCAFControl_Writer
  - symbol: IFSelect_WorkSession
  - symbol: BRepToolsWrapper
  - symbol: GeomToolsWrapper
  - symbol: MeshData
  - symbol: MeshExtractor
  - symbol: BooleanBatch
  - symbol: EdgeMeshData
  - symbol: EdgeMeshExtractor
  - symbol: TopologyResult
  - symbol: TopologyExtractor
  emccFlags:
  - -O3
  - -sEXPORT_ES6=1
  - -sUSE_ES6_IMPORT_META=0
  - -sEXPORTED_RUNTIME_METHODS=["FS"]
  - -sINITIAL_MEMORY=100MB
  - -sMAXIMUM_MEMORY=4GB
  - -sALLOW_MEMORY_GROWTH=1
  - -sLLD_REPORT_UNDEFINED
  - --no-entry
  - -sDISABLE_EXCEPTION_CATCHING=1
  - -sPTHREAD_POOL_SIZE=navigator.hardwareConcurrency
additionalCppCode: |
  class BRepToolsWrapper {
  public:
    static std::string Write(const TopoDS_Shape& shape) {
      std::ostringstream oss(std::ios::binary);
      oss << std::setprecision(17);
      BRepTools::Write(shape, oss);
      return oss.str();
    }
    static TopoDS_Shape Read(const std::string& data) {
      std::istringstream iss(data, std::ios::binary);
      TopoDS_Shape shape;
      BRep_Builder builder;
      Message_ProgressRange progress;
      BRepTools::Read(shape, iss, builder, progress);
      return shape;
    }
  };

  class GeomToolsWrapper {
  public:
    static std::string Write(const Handle(Geom2d_Curve)& geometry) {
      std::ostringstream oss(std::ios::binary);
      oss << std::setprecision(17);
      GeomTools::Write(geometry, oss);
      return oss.str();
    }
    static Handle(Geom2d_Curve) Read(const std::string& data) {
      std::istringstream iss(data, std::ios::binary);
      Handle(Geom2d_Curve) geometry;
      GeomTools::Read(geometry, iss);
      return geometry;
    }
  };

  class MeshData {
  public:
    MeshData()
      : verticesPtr_(nullptr), normalsPtr_(nullptr),
        trianglesPtr_(nullptr), faceGroupsPtr_(nullptr),
        verticesSize_(0), normalsSize_(0),
        trianglesSize_(0), faceGroupsSize_(0) {}

    ~MeshData() {
      std::free(verticesPtr_);
      std::free(normalsPtr_);
      std::free(trianglesPtr_);
      std::free(faceGroupsPtr_);
    }

    // Embind requires a copy constructor; implement as ownership transfer
    // since MeshData owns heap memory and copies are only used by embind internals.
    MeshData(const MeshData& other)
      : verticesPtr_(other.verticesPtr_), normalsPtr_(other.normalsPtr_),
        trianglesPtr_(other.trianglesPtr_), faceGroupsPtr_(other.faceGroupsPtr_),
        verticesSize_(other.verticesSize_), normalsSize_(other.normalsSize_),
        trianglesSize_(other.trianglesSize_), faceGroupsSize_(other.faceGroupsSize_) {
      auto& mutable_other = const_cast<MeshData&>(other);
      mutable_other.verticesPtr_ = nullptr;
      mutable_other.normalsPtr_ = nullptr;
      mutable_other.trianglesPtr_ = nullptr;
      mutable_other.faceGroupsPtr_ = nullptr;
    }

    int getVerticesPtr() const  { return static_cast<int>(reinterpret_cast<uintptr_t>(verticesPtr_)); }
    int getNormalsPtr() const   { return static_cast<int>(reinterpret_cast<uintptr_t>(normalsPtr_)); }
    int getTrianglesPtr() const { return static_cast<int>(reinterpret_cast<uintptr_t>(trianglesPtr_)); }
    int getFaceGroupsPtr() const { return static_cast<int>(reinterpret_cast<uintptr_t>(faceGroupsPtr_)); }

    int getVerticesSize() const   { return verticesSize_; }
    int getNormalsSize() const    { return normalsSize_; }
    int getTrianglesSize() const  { return trianglesSize_; }
    int getFaceGroupsSize() const { return faceGroupsSize_; }

  private:
    float*    verticesPtr_;
    float*    normalsPtr_;
    uint32_t* trianglesPtr_;
    int32_t*  faceGroupsPtr_;

    int verticesSize_;
    int normalsSize_;
    int trianglesSize_;
    int faceGroupsSize_;

    friend class MeshExtractor;
  };

  class MeshExtractor {
  public:
    static MeshData extract(
      const TopoDS_Shape& shape,
      double tolerance,
      double angularTolerance,
      bool skipNormals
    ) {
      BRepMesh_IncrementalMesh mesher(shape, tolerance, Standard_False, angularTolerance, Standard_False);

      int totalNodes = 0;
      int totalTriangles = 0;
      int totalFaces = 0;

      for (TopExp_Explorer ex(shape, TopAbs_FACE); ex.More(); ex.Next()) {
        TopLoc_Location loc;
        Handle(Poly_Triangulation) tri = BRep_Tool::Triangulation(
          TopoDS::Face(ex.Current()), loc);
        if (tri.IsNull()) continue;
        totalNodes += tri->NbNodes();
        totalTriangles += tri->NbTriangles();
        totalFaces++;
      }

      MeshData result;

      result.verticesSize_ = totalNodes * 3;
      result.verticesPtr_ = static_cast<float*>(
        std::malloc(result.verticesSize_ * sizeof(float)));
      if (!result.verticesPtr_ && result.verticesSize_ > 0) throw std::bad_alloc();

      if (!skipNormals) {
        result.normalsSize_ = totalNodes * 3;
        result.normalsPtr_ = static_cast<float*>(
          std::malloc(result.normalsSize_ * sizeof(float)));
        if (!result.normalsPtr_ && result.normalsSize_ > 0) throw std::bad_alloc();
      }

      result.trianglesSize_ = totalTriangles * 3;
      result.trianglesPtr_ = static_cast<uint32_t*>(
        std::malloc(result.trianglesSize_ * sizeof(uint32_t)));
      if (!result.trianglesPtr_ && result.trianglesSize_ > 0) throw std::bad_alloc();

      result.faceGroupsSize_ = totalFaces * 3;
      result.faceGroupsPtr_ = static_cast<int32_t*>(
        std::malloc(result.faceGroupsSize_ * sizeof(int32_t)));
      if (!result.faceGroupsPtr_ && result.faceGroupsSize_ > 0) throw std::bad_alloc();

      int vertexOffset = 0;
      int triOffset = 0;
      int faceGroupIdx = 0;

      for (TopExp_Explorer ex(shape, TopAbs_FACE); ex.More(); ex.Next()) {
        const TopoDS_Face& face = TopoDS::Face(ex.Current());
        TopLoc_Location loc;
        Handle(Poly_Triangulation) tri = BRep_Tool::Triangulation(face, loc);
        if (tri.IsNull()) continue;

        const gp_Trsf& trsf = loc.Transformation();
        int nbNodes = tri->NbNodes();
        int nbTri = tri->NbTriangles();

        for (int i = 1; i <= nbNodes; i++) {
          gp_Pnt p = tri->Node(i).Transformed(trsf);
          int base = (vertexOffset + i - 1) * 3;
          result.verticesPtr_[base + 0] = static_cast<float>(p.X());
          result.verticesPtr_[base + 1] = static_cast<float>(p.Y());
          result.verticesPtr_[base + 2] = static_cast<float>(p.Z());
        }

        if (!skipNormals) {
          TColgp_Array1OfDir normalsArray(1, nbNodes);
          Poly_Connect pc(tri);
          StdPrs_ToolTriangulatedShape::Normal(face, pc, normalsArray);

          for (int i = 1; i <= nbNodes; i++) {
            gp_Dir d = normalsArray.Value(i).Transformed(trsf);
            int base = (vertexOffset + i - 1) * 3;
            result.normalsPtr_[base + 0] = static_cast<float>(d.X());
            result.normalsPtr_[base + 1] = static_cast<float>(d.Y());
            result.normalsPtr_[base + 2] = static_cast<float>(d.Z());
          }
        }

        int faceTriStart = triOffset;
        bool isReversed = (face.Orientation() != TopAbs_FORWARD);
        for (int t = 1; t <= nbTri; t++) {
          const Poly_Triangle& triangle = tri->Triangle(t);
          int n1 = triangle.Value(1);
          int n2 = triangle.Value(2);
          int n3 = triangle.Value(3);

          if (isReversed) {
            int tmp = n1;
            n1 = n2;
            n2 = tmp;
          }

          result.trianglesPtr_[triOffset + 0] = static_cast<uint32_t>(n1 - 1 + vertexOffset);
          result.trianglesPtr_[triOffset + 1] = static_cast<uint32_t>(n2 - 1 + vertexOffset);
          result.trianglesPtr_[triOffset + 2] = static_cast<uint32_t>(n3 - 1 + vertexOffset);
          triOffset += 3;
        }

        int faceHash = face.HashCode(2147483647);
        result.faceGroupsPtr_[faceGroupIdx + 0] = faceTriStart;
        result.faceGroupsPtr_[faceGroupIdx + 1] = (triOffset - faceTriStart);
        result.faceGroupsPtr_[faceGroupIdx + 2] = faceHash;
        faceGroupIdx += 3;

        vertexOffset += nbNodes;
      }

      return result;
    }
  };

  class BooleanBatch {
  public:
    void addShape(const TopoDS_Shape& s) { shapes_.Append(s); }
    void clear() { shapes_.Clear(); }
    int count() const { return shapes_.Size(); }

    TopoDS_Shape fuseAll(int glueMode, bool simplify) {
      if (shapes_.Size() == 0) return TopoDS_Shape();
      if (shapes_.Size() == 1) return shapes_.First();

      BRepAlgoAPI_BuilderAlgo builder;
      builder.SetArguments(shapes_);
      if (glueMode == 1) builder.SetGlue(BOPAlgo_GlueShift);
      if (glueMode == 2) builder.SetGlue(BOPAlgo_GlueFull);

      Message_ProgressRange progress;
      builder.Build(progress);

      TopoDS_Shape result = builder.Shape();
      if (simplify) {
        ShapeUpgrade_UnifySameDomain upgrader(result, Standard_True, Standard_True, Standard_False);
        upgrader.Build();
        result = upgrader.Shape();
      }
      return result;
    }

    TopoDS_Shape cutAll(const TopoDS_Shape& base, int glueMode, bool simplify) {
      if (shapes_.Size() == 0) return base;

      TopoDS_Builder compBuilder;
      TopoDS_Compound toolCompound;
      compBuilder.MakeCompound(toolCompound);
      for (TopTools_ListIteratorOfListOfShape it(shapes_); it.More(); it.Next()) {
        compBuilder.Add(toolCompound, it.Value());
      }

      Message_ProgressRange progress;
      BRepAlgoAPI_Cut cutter(base, toolCompound, progress);
      if (glueMode == 1) cutter.SetGlue(BOPAlgo_GlueShift);
      if (glueMode == 2) cutter.SetGlue(BOPAlgo_GlueFull);
      cutter.Build(progress);

      TopoDS_Shape result = cutter.Shape();
      if (simplify) {
        ShapeUpgrade_UnifySameDomain upgrader(result, Standard_True, Standard_True, Standard_False);
        upgrader.Build();
        result = upgrader.Shape();
      }
      return result;
    }

  private:
    TopTools_ListOfShape shapes_;
  };

  class EdgeMeshData {
  public:
    EdgeMeshData()
      : linesPtr_(nullptr), edgeGroupsPtr_(nullptr),
        linesSize_(0), edgeGroupsSize_(0) {}

    ~EdgeMeshData() {
      std::free(linesPtr_);
      std::free(edgeGroupsPtr_);
    }

    EdgeMeshData(const EdgeMeshData& other)
      : linesPtr_(other.linesPtr_), edgeGroupsPtr_(other.edgeGroupsPtr_),
        linesSize_(other.linesSize_), edgeGroupsSize_(other.edgeGroupsSize_) {
      auto& mutable_other = const_cast<EdgeMeshData&>(other);
      mutable_other.linesPtr_ = nullptr;
      mutable_other.edgeGroupsPtr_ = nullptr;
    }

    int getLinesPtr() const { return static_cast<int>(reinterpret_cast<uintptr_t>(linesPtr_)); }
    int getLinesSize() const { return linesSize_; }
    int getEdgeGroupsPtr() const { return static_cast<int>(reinterpret_cast<uintptr_t>(edgeGroupsPtr_)); }
    int getEdgeGroupsSize() const { return edgeGroupsSize_; }

  private:
    float*   linesPtr_;
    int32_t* edgeGroupsPtr_;
    int linesSize_;
    int edgeGroupsSize_;

    friend class EdgeMeshExtractor;
  };

  class EdgeMeshExtractor {
  public:
    static EdgeMeshData extract(
      const TopoDS_Shape& shape,
      double tolerance,
      double angularTolerance
    ) {
      BRepMesh_IncrementalMesh mesher(shape, tolerance, Standard_False, angularTolerance, Standard_False);

      std::vector<float> lines;
      std::vector<int32_t> edgeGroups;
      NCollection_Map<TopoDS_Shape, TopTools_ShapeMapHasher> seenEdges;

      for (TopExp_Explorer faceEx(shape, TopAbs_FACE); faceEx.More(); faceEx.Next()) {
        const TopoDS_Face& face = TopoDS::Face(faceEx.Current());
        TopLoc_Location faceLoc;
        Handle(Poly_Triangulation) tri = BRep_Tool::Triangulation(face, faceLoc);
        if (tri.IsNull()) continue;

        for (TopExp_Explorer edgeEx(face, TopAbs_EDGE); edgeEx.More(); edgeEx.Next()) {
          const TopoDS_Edge& edge = TopoDS::Edge(edgeEx.Current());
          if (seenEdges.Contains(edge)) continue;
          seenEdges.Add(edge);

          TopLoc_Location edgeLoc;
          Handle(Poly_PolygonOnTriangulation) polygon =
            BRep_Tool::PolygonOnTriangulation(edge, tri, edgeLoc);
          if (polygon.IsNull()) continue;

          const TColStd_Array1OfInteger& nodes = polygon->Nodes();
          if (nodes.Length() < 2) continue;

          int lineStart = static_cast<int>(lines.size()) / 3;
          int pointCount = 0;

          gp_Pnt prevPt;
          bool hasPrev = false;

          for (int i = nodes.Lower(); i <= nodes.Upper(); i++) {
            gp_Pnt p = tri->Node(nodes.Value(i)).Transformed(edgeLoc.Transformation());
            if (hasPrev) {
              lines.push_back(static_cast<float>(prevPt.X()));
              lines.push_back(static_cast<float>(prevPt.Y()));
              lines.push_back(static_cast<float>(prevPt.Z()));
              lines.push_back(static_cast<float>(p.X()));
              lines.push_back(static_cast<float>(p.Y()));
              lines.push_back(static_cast<float>(p.Z()));
              pointCount += 2;
            }
            prevPt = p;
            hasPrev = true;
          }

          int edgeHash = edge.HashCode(2147483647);
          edgeGroups.push_back(lineStart);
          edgeGroups.push_back(pointCount);
          edgeGroups.push_back(edgeHash);
        }
      }

      for (TopExp_Explorer edgeEx(shape, TopAbs_EDGE); edgeEx.More(); edgeEx.Next()) {
        const TopoDS_Edge& edge = TopoDS::Edge(edgeEx.Current());
        if (seenEdges.Contains(edge)) continue;
        seenEdges.Add(edge);

        BRepAdaptor_Curve adaptor(edge);
        GCPnts_TangentialDeflection tangDef(adaptor, tolerance, angularTolerance, 2, 1e-9, 1e-7);
        int nbPts = tangDef.NbPoints();
        if (nbPts < 2) continue;

        int lineStart = static_cast<int>(lines.size()) / 3;
        int pointCount = 0;

        gp_Pnt prevPt;
        bool hasPrev = false;

        for (int j = 1; j <= nbPts; j++) {
          gp_Pnt p = tangDef.Value(j);
          if (hasPrev) {
            lines.push_back(static_cast<float>(prevPt.X()));
            lines.push_back(static_cast<float>(prevPt.Y()));
            lines.push_back(static_cast<float>(prevPt.Z()));
            lines.push_back(static_cast<float>(p.X()));
            lines.push_back(static_cast<float>(p.Y()));
            lines.push_back(static_cast<float>(p.Z()));
            pointCount += 2;
          }
          prevPt = p;
          hasPrev = true;
        }

        int edgeHash = edge.HashCode(2147483647);
        edgeGroups.push_back(lineStart);
        edgeGroups.push_back(pointCount);
        edgeGroups.push_back(edgeHash);
      }

      EdgeMeshData result;

      result.linesSize_ = static_cast<int>(lines.size());
      if (result.linesSize_ > 0) {
        result.linesPtr_ = static_cast<float*>(std::malloc(result.linesSize_ * sizeof(float)));
        if (!result.linesPtr_) throw std::bad_alloc();
        std::memcpy(result.linesPtr_, lines.data(), result.linesSize_ * sizeof(float));
      }

      result.edgeGroupsSize_ = static_cast<int>(edgeGroups.size());
      if (result.edgeGroupsSize_ > 0) {
        result.edgeGroupsPtr_ = static_cast<int32_t*>(std::malloc(result.edgeGroupsSize_ * sizeof(int32_t)));
        if (!result.edgeGroupsPtr_) throw std::bad_alloc();
        std::memcpy(result.edgeGroupsPtr_, edgeGroups.data(), result.edgeGroupsSize_ * sizeof(int32_t));
      }

      return result;
    }
  };

  class TopologyResult {
  public:
    TopologyResult() : shapesPtr_(nullptr), shapesCount_(0) {}

    ~TopologyResult() {
      delete[] shapesPtr_;
    }

    TopologyResult(const TopologyResult& other)
      : shapesPtr_(other.shapesPtr_), shapesCount_(other.shapesCount_) {
      auto& mutable_other = const_cast<TopologyResult&>(other);
      mutable_other.shapesPtr_ = nullptr;
    }

    int getShapesCount() const { return shapesCount_; }
    TopoDS_Shape getShape(int index) const { return shapesPtr_[index]; }

  private:
    TopoDS_Shape* shapesPtr_;
    int shapesCount_;

    friend class TopologyExtractor;
  };

  class TopologyExtractor {
  public:
    static TopologyResult extract(const TopoDS_Shape& shape, int shapeType) {
      TopAbs_ShapeEnum topoType = static_cast<TopAbs_ShapeEnum>(shapeType);
      NCollection_Map<TopoDS_Shape, TopTools_ShapeMapHasher> seen;
      std::vector<TopoDS_Shape> shapes;

      for (TopExp_Explorer ex(shape, topoType); ex.More(); ex.Next()) {
        const TopoDS_Shape& item = ex.Current();
        if (seen.Add(item)) {
          shapes.push_back(item);
        }
      }

      TopologyResult result;
      result.shapesCount_ = static_cast<int>(shapes.size());
      if (result.shapesCount_ > 0) {
        result.shapesPtr_ = new TopoDS_Shape[result.shapesCount_];
        for (int i = 0; i < result.shapesCount_; i++) {
          result.shapesPtr_[i] = shapes[i];
        }
      }
      return result;
    }
  };
