# brepjs

> Web CAD library built on OpenCascade with a layered architecture and kernel abstraction layer. Create 2D sketches, extrude/revolve/loft/sweep into 3D solids, apply booleans/fillets/chamfers/shells, query topology, measure geometry, heal shapes, manage assemblies, and import/export STEP, STL, IGES, glTF, DXF, 3MF, OBJ, and SVG.

## Setup & Initialization

Install:
```bash
npm install brepjs brepjs-opencascade
```

Initialize the WASM kernel before any CAD operations:
```typescript
import opencascade from 'brepjs-opencascade';
import { initFromOC } from 'brepjs';

const oc = await opencascade();
initFromOC(oc);
```

`initFromOC(oc)` must be called once before using any brepjs API. All shape-creating functions require the kernel to be initialized.

## API Style

brepjs uses a functional API with branded types (`Solid`, `Face`, `Edge`, etc.) and `Result<T>` for error handling. Functions like `fuseShape()`, `translateShape()`, `filletShape()` are pure — they never dispose inputs. Use `unwrap()` to extract values from `Result<T>`, or `isOk()`/`isErr()` to check success.

### Branded Shape Types

Shape types are lightweight branded handles (not classes):
- `Vertex` — use `vertexPosition(v)` to get coordinates
- `Edge`, `Wire` — use `curveStartPoint()`, `curveEndPoint()`, `curveLength()`, `getCurveType()`, etc.
- `Face` — use `normalAt()`, `faceCenter()`, `faceGeomType()`, `uvBounds()`, `pointOnSurface()`, `outerWire()`, `innerWires()`
- `Shell`, `Solid`, `CompSolid`, `Compound` — 3D shapes for booleans/modifiers
- `AnyShape` — union of all shape types
- `Shape3D` — union of Shell | Solid | CompSolid | Compound

All shapes have `.wrapped` (OCCT handle) and `.delete()`. Use `using` syntax for auto-cleanup.

Also exported: `Sketch`, `CompoundSketch`, `Sketches` (multi-profile container), `Drawing`, `DrawingPen`, `Blueprint`, `CompoundBlueprint`, `Blueprints`

### Type Conversion Helpers

```typescript
import { toVec3, toVec2, resolveDirection } from 'brepjs';

toVec3([x, y]): Vec3          // 2D → 3D (z=0)
toVec3([x, y, z]): Vec3       // identity
toVec2([x, y, z]): Vec2       // 3D → 2D (drop z)
resolveDirection('X'): Vec3    // → [1, 0, 0]
resolveDirection('Y'): Vec3    // → [0, 1, 0]
resolveDirection('Z'): Vec3    // → [0, 0, 1]
resolveDirection([a, b, c]): Vec3 // identity
```

### Shape Serialization

```typescript
import { serializeShape, deserializeShape } from 'brepjs';

const brep = serializeShape(shape);    // shape → BREP string
const restored = deserializeShape(brep); // BREP string → AnyShape
```

## Drawing & Sketching (Primary Entry Point)

Most workflows start by drawing a 2D profile, then extruding or revolving it into 3D.

### DrawingPen (2D builder)

```typescript
import { draw, drawRectangle, drawCircle, drawPolysides } from 'brepjs';

// Freeform drawing with a pen
const shape2d = draw()
  .movePointerTo([0, 0])
  .lineTo([10, 0])
  .lineTo([10, 5])
  .hLine(-5)
  .vLine(5)
  .close();

// Canned shapes
const rect = drawRectangle(100, 50);
const circle = drawCircle(25);
const hex = drawPolysides(10, 6);
```

DrawingPen methods:
- `movePointerTo(point)` — Move without drawing
- `lineTo(point)`, `line(dx, dy)`, `hLine(d)`, `vLine(d)` — Straight lines
- `hLineTo(xPos)`, `vLineTo(yPos)` — Absolute line targets
- `polarLine(distance, angle)`, `polarLineTo(point)` — Polar coordinates
- `tangentLine(distance)` — Tangent continuation
- `threePointsArcTo(end, innerPoint)`, `threePointsArc(dx, dy, viaX, viaY)` — 3-point arcs
- `tangentArcTo(end)`, `tangentArc(dx, dy)` — Tangent arcs
- `sagittaArcTo(end, sagitta)`, `sagittaArc(dx, dy, sagitta)` — Sagitta arcs
- `vSagittaArc(d, sagitta)`, `hSagittaArc(d, sagitta)` — Vertical/horizontal sagitta arcs
- `bulgeArcTo(end, bulge)`, `bulgeArc(dx, dy, bulge)` — Bulge arcs
- `vBulgeArc(d, bulge)`, `hBulgeArc(d, bulge)` — Vertical/horizontal bulge arcs
- `ellipseTo(end, hRadius, vRadius, rotation?, longAxis?, sweep?)` — Elliptical arcs
- `halfEllipseTo(end, vRadius, sweep?)` — Half-ellipse arcs
- `bezierCurveTo(end, controlPoints)` — General Bezier
- `quadraticBezierCurveTo(end, control)` — Quadratic Bezier
- `cubicBezierCurveTo(end, c1, c2)` — Cubic Bezier
- `smoothSplineTo(end, config?)`, `smoothSpline(dx, dy, config?)` — Smooth splines
- `fillet(radius)`, `chamfer(radius)` — Corner treatments (call before next segment)
- `close()` — Close the path and return a Drawing
- `closeWithMirror()` — Close by mirroring the path
- `closeWithCustomCorner(radius, mode?)` — Close with a fillet or chamfer at the join. `mode`: `'fillet'` (default) or `'chamfer'`
- `done()` — Leave path open and return a Drawing

Drawing factory functions:
- `draw(origin?)` — Start a new pen at optional `[x, y]` point
- `drawRectangle(w, h, r?)` — Rectangle centered at origin, optional corner radius `r: number` or `{rx?, ry?}`
- `drawRoundedRectangle(w, h, r?)` — Alias for `drawRectangle`
- `drawCircle(radius)` — Circle centered at origin (built from two sagitta arcs)
- `drawSingleCircle(radius)` — Circle as a single curve primitive (more efficient, less compatible with corner ops)
- `drawEllipse(major, minor)` — Ellipse centered at origin (built from two half-ellipse arcs)
- `drawSingleEllipse(major, minor)` — Ellipse as a single curve primitive
- `drawPolysides(radius, sides, sagitta?)` — Regular polygon. `sagitta` curves the sides (positive = outward)
- `drawText(text, {startX?, startY?, fontSize?, fontFamily?})` — Text outline (requires `loadFont()` first)
- `drawPointsInterpolation(points, approxConfig?, {closeShape?})` — BSpline through Point2D[]. `approxConfig`: `{tolerance?, degMax?, degMin?, smoothing?}`
- `drawParametricFunction(fn, {pointsCount?, start?, stop?, closeShape?}, approxConfig?)` — Parametric curve `fn: (t: number) => Point2D`
- `drawProjection(shape, camera?)` — Project 3D shape to 2D. `camera`: `ProjectionPlane | Camera` (default `'front'`). Returns `{visible: Drawing, hidden: Drawing}`
- `drawFaceOutline(face)` — Extract face outer wire as a 2D Drawing
- `deserializeDrawing(data)` — Reconstruct from string produced by `drawing.serialize()`

Drawing instance methods:
- `clone()`, `serialize()` — Copy and serialization
- `boundingBox` — Get `BoundingBox2d`
- `repr` — String representation of the drawing
- `blueprint` — Access the underlying `Blueprint` (throws if compound)
- `translate(dx, dy)` or `translate([dx, dy])` — Move the drawing
- `rotate(angle, center?)` — Rotate in degrees around optional center point
- `scale(factor, center?)` — Uniform scale around optional center
- `mirror(dirOrCenter, origin?, mode?)` — Mirror. `mode`: `'center'` (default) or `'plane'`
- `stretch(ratio, direction, origin)` — Non-uniform scaling along a direction
- `cut(other)`, `fuse(other)`, `intersect(other)` — 2D boolean operations (return new Drawing)
- `fillet(radius, filter?)`, `chamfer(radius, filter?)` — Corner treatments. `filter`: `(c: CornerFinderFn) => CornerFinderFn`
- `offset(distance, config?)` — Offset all curves by distance
- `approximate('svg', options?)` — Approximate curves for SVG compatibility
- `sketchOnPlane(plane?, origin?)` — Convert to 3D Sketch/Sketches. Returns `SketchInterface | Sketches`
- `sketchOnFace(face, scaleMode)` — Project onto a face. `scaleMode`: controls UV mapping behavior
- `punchHole(shape, faceFinder, {height?, origin?, draftAngle?}?)` — Punch this 2D profile through a 3D shape
- `toSVG(margin?)` — Full SVG string with `<svg>` tag
- `toSVGViewBox(margin?)` — SVG string with viewBox attribute
- `toSVGPaths()` — Array of SVG path `d` strings

### Sketcher (3D sketching on a plane)

```typescript
import { Sketcher, sketchCircle, sketchRectangle } from 'brepjs';

// Sketch on XY plane, then extrude
const box = new Sketcher('XY')
  .movePointerTo([-5, -5])
  .lineTo([5, -5])
  .lineTo([5, 5])
  .lineTo([-5, 5])
  .close()
  .extrude(10);

// Canned sketch shortcuts
const cylinder = sketchCircle(10).extrude(20);
const prism = sketchRectangle(30, 20).extrude(15);

// Sketching on offset planes
const top = sketchCircle(5, { plane: 'XY', origin: 20 });  // XY plane at Z=20
const angled = sketchCircle(5, { plane: myCustomPlane });    // custom Plane object
```

Sketcher has the same drawing methods as DrawingPen plus arc/ellipse/spline methods, closing with `.close()` or `.done()` to produce a `Sketch`.

Canned sketch functions — all accept an optional last argument `PlaneConfig = { plane?: PlaneName | Plane, origin?: PointInput | number }`. When `origin` is a number, it offsets the named plane along its normal by that distance:
- `sketchCircle(radius, planeConfig?)` — Circle sketch
- `sketchRectangle(w, h, planeConfig?)` — Rectangle sketch
- `sketchRoundedRectangle(w, h, r?, planeConfig?)` — Rounded rectangle. `r`: `number` or `{rx?, ry?}`
- `sketchPolysides(radius, sides, sagitta?, planeConfig?)` — Regular polygon
- `sketchEllipse(xRadius?, yRadius?, planeConfig?)` — Ellipse (defaults: xRadius=1, yRadius=2)
- `sketchHelix(pitch, height, radius, center?, dir?, lefthand?)` — Helix curve (no PlaneConfig; uses center/dir directly)
- `sketchFaceOffset(face, offset)` — Offset a face boundary (negative = inward, positive = outward)
- `sketchParametricFunction(fn, planeConfig?, {pointsCount?, start?, stop?}?, approxConfig?)` — Parametric curve on plane
- `polysideInnerRadius(outerRadius, sidesCount, sagitta?)` — Helper: compute inner radius of a polyside

Sketch instance methods:
- `extrude(distance, options?)` — Options: `{extrusionDirection?, extrusionProfile?, twistAngle?, origin?}`
- `revolve(axis?, {origin?})` — Revolve around axis
- `loftWith(otherSketches, config?, returnShell?)` — Loft between profiles
- `sweepSketch(sketchOnPlane, config?)` — Sweep along a spine
- `face()` — Convert to face
- `wires()` — Get wire(s)
- `clone()`, `delete()` — Copy and cleanup

### Drawing to 3D

```typescript
// Drawing → Sketch → 3D
const profile = drawRectangle(20, 10);
const sketch = profile.sketchOnPlane('XY');
const solid = sketch.extrude(5);
```

Plane names: `'XY'`, `'XZ'`, `'YZ'`, `'ZX'`, `'YX'`, `'ZY'`, `'front'`, `'back'`, `'top'`, `'bottom'`, `'left'`, `'right'`

## 3D Operations

### Extrude & Revolve

```typescript
// Extrude a sketch into a solid
const box = sketchRectangle(10, 10).extrude(20);

// Twist extrude
const twisted = sketchRectangle(10, 10).extrude(20, { twistAngle: 45 });

// Revolve around an axis (default direction: sketch's defaultDirection)
const sphere = sketchCircle(5, { plane: 'XZ' }).revolve();
const halfTorus = sketchCircle(2, { plane: 'XZ' }).revolve([10, 0, 0], { origin: [0, 0, 0] });
```

Functional API:
- `extrudeFace(face, extrusionVec: Vec3): Solid` — Extrude a face along a direction vector. Vector direction = extrusion direction, vector length = distance
- `revolveFace(face, center?, direction?, angle?): Result<Shape3D>` — Revolve a face. `center` default `[0,0,0]`, `direction` default `[0,0,1]` (Z axis), `angle` default `360` degrees
- `sweep(wire, spine, config?, shellMode?): Result<Shape3D | [Shape3D, Wire, Wire]>` — Sweep profile along spine
- `complexExtrude(wire, center, normal, profileShape?, shellMode?): Result<Shape3D>` — Extrude with scaling profile
- `twistExtrude(wire, angleDeg, center, normal, profileShape?, shellMode?): Result<Shape3D>` — Twist extrude with rotation
- `supportExtrude(wire, center, normal, support): Result<Shape3D>` — Extrude constrained to a support surface

`ExtrusionProfile`: `{ profile?: 's-curve' | 'linear', endFactor?: number }` — Controls scaling along extrusion path. `endFactor` 1 = same size, 0.5 = half size at end.

`SweepConfig`: `{ frenet?, auxiliarySpine?, law?, transitionMode?: 'right' | 'transformed' | 'round', withContact?, support?, forceProfileSpineOthogonality? }`

### Loft & Sweep

```typescript
import { sketchCircle, sketchRectangle } from 'brepjs';

// Loft between profiles
const bottom = sketchCircle(10);
const top = sketchCircle(5, { plane: 'XY', origin: 20 }); // XY plane offset to Z=20
const lofted = bottom.loftWith([top]);

// Sweep a profile along a spine (sweepSketch takes a function that builds the profile)
const spine = sketchHelix(10, 50, 20);
const coil = spine.sweepSketch((plane, origin) =>
  new Sketcher(plane).movePointerTo([-2, -2]).lineTo([2, -2]).lineTo([2, 2]).lineTo([-2, 2]).close()
);
```

Functional API:
- `loftWires(wires, config?, returnShell?): Result<Shape3D>` — Loft config: `{ruled?: boolean (default true), startPoint?: PointInput, endPoint?: PointInput}`
- `sketchLoft(sketch, otherSketches, config?, returnShell?): Shape3D`
- `sketchSweep(sketch, sketchOnPlane, sweepConfig?): Shape3D`
- `sketchExtrude(sketch, height, config?): Shape3D` — Functional version of `sketch.extrude()`
- `sketchRevolve(sketch, axis?, {origin?}?): Shape3D` — Functional version of `sketch.revolve()`
- `sketchFace(sketch): Face` — Get the face from a closed sketch
- `sketchWires(sketch): Wire` — Get the wire from a sketch

CompoundSketch functions (for multi-contour profiles like text):
- `compoundSketchExtrude(sketch, height, config?): Shape3D`
- `compoundSketchRevolve(sketch, axis?, {origin?}?): Shape3D`
- `compoundSketchFace(sketch): Face`
- `compoundSketchLoft(sketch, other, loftConfig): Shape3D`

Drawing functional API:
- `drawingToSketchOnPlane(drawing, plane?, origin?): SketchInterface | Sketches`
- `drawingFuse(a, b): Drawing`
- `drawingCut(a, b): Drawing`
- `drawingIntersect(a, b): Drawing`
- `drawingFillet(drawing, radius, filter?): Drawing`
- `drawingChamfer(drawing, radius, filter?): Drawing`
- `translateDrawing(drawing, dx, dy): Drawing` or `translateDrawing(drawing, [dx, dy])`
- `rotateDrawing(drawing, angle, center?): Drawing`
- `scaleDrawing(drawing, factor, center?): Drawing`
- `mirrorDrawing(drawing, dir, origin?, mode?): Drawing`

### Boolean Operations

```typescript
import { fuseShape, cutShape, intersectShape, unwrap } from 'brepjs';

const box = sketchRectangle(20, 20).extrude(20);
const hole = sketchCircle(5).extrude(30);

const withHole = unwrap(cutShape(box, hole));        // Subtraction → Result<Shape3D>
const merged = unwrap(fuseShape(box, hole));         // Union → Result<Shape3D>
const common = unwrap(intersectShape(box, hole));    // Intersection → Result<Shape3D>
```

Full boolean API:
```typescript
import { fuseShape, cutShape, intersectShape, sectionShape, splitShape, sliceShape } from 'brepjs';

fuseShape(a, b, options?): Result<Shape3D>
cutShape(base, tool, options?): Result<Shape3D>
intersectShape(a: Shape3D, b: Shape3D, options?): Result<Shape3D>
sectionShape(shape, plane, {approximation?, planeSize?}?): Result<AnyShape>
splitShape(shape, tools): Result<AnyShape>
sliceShape(shape, planes, options?): Result<AnyShape[]>
```

All boolean operations validate inputs before calling OCCT: null shapes return `VALIDATION` errors with code `NULL_SHAPE_INPUT` and a message identifying which operand was invalid.

Boolean options: `{ optimisation?: 'none' | 'commonFace' | 'sameFace', simplify?: boolean, strategy?: 'native' | 'pairwise', signal?: AbortSignal }`

Batch: `fuseAll(shapes, options?): Result<Shape3D>`, `cutAll(base, tools, options?): Result<Shape3D>`

### Fillet & Chamfer

```typescript
import { filletShape, chamferShape, chamferDistAngleShape, getEdges, edgeFinder } from 'brepjs';

// Fillet all edges — returns Result<Shape3D>
const rounded = unwrap(filletShape(box, getEdges(box), 2));

// Fillet specific edges using edgeFinder
const selective = unwrap(filletShape(box, edgeFinder().ofLength(20).findAll(box), 2));

// Chamfer
const chamfered = unwrap(chamferShape(box, getEdges(box), 1));
```

Additional functional API:
```typescript
import { filletShape, chamferShape, chamferDistAngleShape } from 'brepjs';

filletShape(shape, edges, radius): Result<Shape3D>
// radius: number | [r1, r2] | (edge => number | [r1, r2] | null)

chamferShape(shape, edges, distance): Result<Shape3D>
// distance: number | [d1, d2] | (edge => number | [d1, d2] | null)

chamferDistAngleShape(shape, edges, distance, angleDeg): Result<Shape3D>
```

### Shell (Hollow Out)

```typescript
import { shellShape, faceFinder } from 'brepjs';

// Remove top face and shell to 1mm thickness — returns Result<Shape3D>
const topFaces = faceFinder().parallelTo('XY').findAll(box);
const hollowed = unwrap(shellShape(box, topFaces, 1));
```

`shellShape(shape, faces, thickness, tolerance?): Result<Shape3D>`

All modifier operations (`filletShape`, `chamferShape`, `shellShape`, `offsetShape`, `thickenSurface`) validate that the input shape is not null before calling OCCT, returning `NULL_SHAPE_INPUT` validation errors. Error messages from OCCT failures include operation name and parameter metadata (edge count, radius, distance).

### Offset & Thicken

```typescript
import { offsetShape, thickenSurface } from 'brepjs';

offsetShape(shape: Shape3D, distance, tolerance?): Result<Shape3D>
thickenSurface(shape: Face | Shell, thickness): Result<Solid>
```

### Transformations

```typescript
import { translateShape, rotateShape, mirrorShape, scaleShape } from 'brepjs';

translateShape(shape, [10, 0, 0]): T
rotateShape(shape, angle, position?, direction?): T
mirrorShape(shape, planeNormal?, planeOrigin?): T
scaleShape(shape, factor, center?): T
```

### Patterns

```typescript
import { linearPattern, circularPattern } from 'brepjs';

// 5 total copies along X with 10mm spacing (original + 4 copies, fused together)
const row = linearPattern(shape, [1, 0, 0], 5, 10);

// 8 copies in a full circle around Z axis (fused together)
const ring = circularPattern(shape, [0, 0, 1], 8);

// 6 copies in 180-degree arc around Z, centered at [10, 0, 0]
const arc = circularPattern(shape, [0, 0, 1], 6, 180, [10, 0, 0]);
```

`linearPattern(shape, direction, count, spacing, options?)`: `count` includes the original. Returns `Result<Shape3D>` (all copies fused).

`circularPattern(shape, axis, count, fullAngle?, center?, options?)`: `fullAngle` default 360 degrees. `center` default `[0,0,0]`. Returns `Result<Shape3D>`.

### Pipe (Fluent Functional API)

```typescript
import { pipe } from 'brepjs';

const result = pipe(shape)
  .translate([10, 0, 0])
  .rotate(45)
  .fuse(otherShape)
  .cut(hole)
  .done();
```

ShapePipe methods: `.translate(v)`, `.rotate(angle, pos?, dir?)`, `.mirror(normal?, origin?)`, `.scale(factor, center?)`, `.fuse(tool, opts?)`, `.cut(tool, opts?)`, `.intersect(tool)`, `.apply(fn)`, `.done()`

## Shape Queries

### Shape Introspection

```typescript
import { cloneShape, describeShape, getBounds, isShapeNull, isSameShape, isEqualShape, simplifyShape } from 'brepjs';

cloneShape(shape): T                    // Deep clone
describeShape(shape): ShapeDescription  // {kind, faceCount, edgeCount, wireCount, vertexCount, valid, bounds}
getBounds(shape): Bounds3D              // {xMin, xMax, yMin, yMax, zMin, zMax}
isShapeNull(shape): boolean
isSameShape(a, b): boolean              // Same topology reference
isEqualShape(a, b): boolean             // Geometrically equal
simplifyShape(shape): T
serializeShape(shape): string
getHashCode(shape): number
```

### Topology Traversal

```typescript
import { getEdges, getFaces, getWires, getVertices, vertexPosition } from 'brepjs';

getEdges(shape): Edge[]
getFaces(shape): Face[]
getWires(shape): Wire[]
getVertices(shape): Vertex[]
vertexPosition(vertex): Vec3

// Iterator versions (lazy)
iterEdges(shape): Generator<Edge>
iterFaces(shape): Generator<Face>
iterWires(shape): Generator<Wire>
iterVertices(shape): Generator<Vertex>
```

### Adjacency Queries

```typescript
import { facesOfEdge, edgesOfFace, wiresOfFace, verticesOfEdge, adjacentFaces, sharedEdges } from 'brepjs';

facesOfEdge(parent, edge): Face[]
edgesOfFace(face): Edge[]
wiresOfFace(face): Wire[]
verticesOfEdge(edge): Vertex[]
adjacentFaces(parent, face): Face[]
sharedEdges(face1, face2): Edge[]
```

### Immutable Finders (Functional API)

```typescript
import { edgeFinder, faceFinder, wireFinder, vertexFinder } from 'brepjs';

// Composable, immutable chain — findAll returns T[]
const topEdges = edgeFinder()
  .inDirection([0, 0, 1])
  .ofLength(10, tolerance?)
  .ofCurveType('LINE')
  .findAll(shape);

const topFaces = faceFinder()
  .inDirection('Z')                // Faces whose normal aligns with Z (shorthand for [0,0,1])
  .ofSurfaceType('PLANE')
  .ofArea(100, tolerance?)
  .findAll(shape);
// faceFinder also has: .parallelTo(dir) (alias for inDirection(dir, 0)), .atDistance(dist, point?)

const closedWires = wireFinder()
  .isClosed()
  .ofEdgeCount(4)
  .findAll(shape);

const cornerVerts = vertexFinder()
  .atPosition([0, 0, 0], tolerance?)
  .nearestTo([10, 0, 0])
  .withinBox([0, 0, 0], [10, 10, 10])
  .findAll(shape);

// findUnique — returns Result<T>, errors if 0 or >1 matches
const uniqueEdge = edgeFinder().ofLength(10).findUnique(shape);

// Combinators (available on all finders)
edgeFinder().not(f => f.ofCurveType('LINE')).findAll(shape);
edgeFinder().either([f => f.ofLength(10), f => f.ofLength(20)]).findAll(shape);
edgeFinder().when(edge => customPredicate(edge)).findAll(shape);
edgeFinder().inList(knownEdges).findAll(shape);
```

### cornerFinder (2D)

```typescript
import { cornerFinder } from 'brepjs';

// Immutable builder pattern — each method returns a new finder
cornerFinder().inList(points).find(blueprint);
cornerFinder().atDistance(dist, point?).find(blueprint);
cornerFinder().atPoint(point).find(blueprint);
cornerFinder().inBox(corner1, corner2).find(blueprint);
cornerFinder().ofAngle(angle).find(blueprint);
cornerFinder().not(f => f.atPoint([0, 0])).find(blueprint);
cornerFinder().either([f => f.atPoint([0, 0]), f => f.atPoint([1, 1])]).find(blueprint);
cornerFinder().when(corner => customPredicate(corner)).find(blueprint);
```

> **Note:** `EdgeFinder`, `FaceFinder`, and `CornerFinder` classes are deprecated. Use `edgeFinder()`, `faceFinder()`, and `cornerFinder()` factories instead.

## Curve Operations

```typescript
import {
  getCurveType, curveStartPoint, curveEndPoint,
  curvePointAt, curveTangentAt, curveLength,
  curveIsClosed, curveIsPeriodic, curvePeriod,
  getOrientation, flipOrientation, offsetWire2D,
  interpolateCurve, approximateCurve
} from 'brepjs';

getCurveType(edge): CurveType        // 'LINE' | 'CIRCLE' | 'ELLIPSE' | 'BEZIER_CURVE' | 'BSPLINE_CURVE' | ...
curveStartPoint(shape): Vec3
curveEndPoint(shape): Vec3
curvePointAt(shape, t?): Vec3           // Point at parameter t (0-1)
curveTangentAt(shape, t?): Vec3         // Tangent at parameter t
curveLength(shape): number
curveIsClosed(shape): boolean
curveIsPeriodic(shape): boolean
curvePeriod(shape): number
getOrientation(shape): 'forward' | 'backward'
flipOrientation(shape): Edge | Wire

// Create curves from points
interpolateCurve(points, {periodic?, tolerance?}?): Result<Edge>
approximateCurve(points, {tolerance?, degMin?, degMax?, smoothing?}?): Result<Edge>

// 2D wire offset
offsetWire2D(wire, offset, kind?): Result<Wire>   // kind: 'arc' | 'intersection' | 'tangent'
```

## Face Operations

```typescript
import {
  getSurfaceType, faceGeomType, faceOrientation, flipFaceOrientation,
  uvBounds, pointOnSurface, uvCoordinates, normalAt,
  faceCenter, classifyPointOnFace, outerWire, innerWires,
  projectPointOnFace
} from 'brepjs';

getSurfaceType(face): Result<SurfaceType>   // 'PLANE' | 'CYLINDRE' | 'CONE' | 'SPHERE' | 'TORUS' | 'BSPLINE_SURFACE' | ...
faceGeomType(face): SurfaceType
faceOrientation(face): 'forward' | 'backward'
flipFaceOrientation(face): Face
uvBounds(face): { uMin, uMax, vMin, vMax }
pointOnSurface(face, u, v): Vec3
uvCoordinates(face, point): [number, number]
normalAt(face, point?): Vec3
faceCenter(face): Vec3
classifyPointOnFace(face, point, tolerance?): 'in' | 'on' | 'out'
outerWire(face): Wire
innerWires(face): Wire[]
projectPointOnFace(face, point): Result<{ uv, point, distance }>
```

## Measurements

```typescript
import {
  measureVolume, measureArea, measureLength,
  measureDistance
} from 'brepjs';

measureVolume(solid);                           // number
measureArea(face);                              // number
measureLength(edge);                            // number
measureDistance(shape1, shape2);                 // number
```

Functional measurement API:
```typescript
import {
  measureVolume, measureArea, measureLength, measureDistance,
  measureVolumeProps, measureSurfaceProps, measureLinearProps,
  createDistanceQuery, measureCurvatureAt, measureCurvatureAtMid
} from 'brepjs';

measureVolumeProps(shape): { volume, mass, centerOfMass }
measureSurfaceProps(shape): { area, mass, centerOfMass }
measureLinearProps(shape): { length, mass, centerOfMass }
measureDistance(shape1, shape2): number
createDistanceQuery(ref): { distanceTo(other): number, dispose(): void }

// Surface curvature
measureCurvatureAt(face, u, v): CurvatureResult
measureCurvatureAtMid(face): CurvatureResult
// CurvatureResult: { mean, gaussian, maxCurvature, minCurvature, maxDirection, minDirection }
```

### Interference Detection

```typescript
import { checkInterference, checkAllInterferences } from 'brepjs';

checkInterference(shape1, shape2, tolerance?): Result<InterferenceResult>
// InterferenceResult: { hasInterference, minDistance, pointOnShape1, pointOnShape2 }

checkAllInterferences(shapes, tolerance?): InterferencePair[]
// InterferencePair: { i, j, result: InterferenceResult }
```

## Shape Healing & Validation

```typescript
import { isShapeValid, healSolid, healFace, healWire, healShape, autoHeal } from 'brepjs';

isShapeValid(shape): boolean
healSolid(solid): Result<Solid>
healFace(face): Result<Face>
healWire(wire, face?): Result<Wire>
healShape(shape): Result<T>

// Auto-healing pipeline with diagnostics
autoHeal(shape, options?): Result<{ shape, report: HealingReport }>
// Options: { fixWires?: boolean (default true), fixFaces?: boolean (default true),
//            fixSolids?: boolean (default true), sewTolerance?: number,
//            fixSelfIntersection?: boolean (default FALSE — unlike the others) }
// HealingReport: { isValid, alreadyValid, wiresHealed, facesHealed, solidHealed, steps, diagnostics }
// alreadyValid: true when shape was valid before healing — distinguishes "nothing to fix" from "fix succeeded"
```

## Import / Export

### STEP Files

```typescript
import { importSTEP, exportSTEP } from 'brepjs';

// Import
const blob = new Blob([stepFileBytes]);
const result = await importSTEP(blob);   // Result<AnyShape>

// Export with color and names
const stepBlob = exportSTEP([
  { shape: body, color: '#3366cc', name: 'Body' },
  { shape: lid, color: '#cc6633', name: 'Lid' },
], { unit: 'MM' });
```

Functional API:
```typescript
import { importSTEP, exportSTEP, exportAssemblySTEP } from 'brepjs';

importSTEP(blob): Promise<Result<AnyShape>>
exportSTEP(shape): Result<Blob>
exportAssemblySTEP(shapes, { unit?, modelUnit? }?): Result<Blob>
// ShapeConfig: { shape, color?, alpha?, name? }
// SupportedUnit: 'millimeter' | 'centimeter' | 'meter' | 'inch' | 'foot'
```

### STL Files

```typescript
import { importSTL, exportSTL } from 'brepjs';

importSTL(blob): Promise<Result<AnyShape>>
exportSTL(shape, { tolerance?, angularTolerance?, binary? }?): Result<Blob>
```

### IGES Files

```typescript
import { importIGES, exportIGES } from 'brepjs';

importIGES(blob): Promise<Result<AnyShape>>
exportIGES(shape): Result<Blob>
```

### glTF / GLB (with PBR materials)

```typescript
import { exportGltf, exportGlb } from 'brepjs';

const json = exportGltf(mesh, options?);       // glTF JSON string
const binary = exportGlb(mesh, options?);       // GLB ArrayBuffer

// GltfExportOptions: { materials?: Map<faceId, GltfMaterial> }
// GltfMaterial: { name?, baseColor?: [r,g,b,a], metallic?: number, roughness?: number }
```

### DXF

```typescript
import { exportDXF, blueprintToDXF } from 'brepjs';

exportDXF(entities, options?): string
blueprintToDXF(drawing, options?): string
// DXFExportOptions: { layer?, curveSegments? }
// DXFEntity: { type: 'LINE', start, end, layer? } | { type: 'POLYLINE', points, closed?, layer? }
```

### 3MF

```typescript
import { exportThreeMF } from 'brepjs';

exportThreeMF(mesh, options?): ArrayBuffer
// ThreeMFExportOptions: { name?, unit?: 'micron' | 'millimeter' | 'centimeter' | 'meter' | 'inch' | 'foot' }
```

### OBJ

```typescript
import { exportOBJ } from 'brepjs';

exportOBJ(mesh): string
```

### SVG Import

```typescript
import { importSVGPathD, importSVG } from 'brepjs';

importSVGPathD(pathD): Result<Blueprint>       // Single SVG path d attribute
importSVG(svgString): Result<Blueprint[]>      // Extract all <path> elements from SVG string
// SVGImportOptions type is exported: { flipY?: boolean } (Y-axis is flipped by default since SVG Y is down)
```

## Topology Helpers

Create shapes directly without the sketching API:

```typescript
import {
  makeLine, makeCircle, makeEllipse, makeHelix,
  makeThreePointArc, makeEllipseArc, makeTangentArc,
  makeBSplineApproximation, makeBezierCurve,
  assembleWire, makeFace, makeNonPlanarFace, makeNewFaceWithinFace,
  addHolesInFace, makePolygon,
  makeCylinder, makeSphere, makeCone, makeTorus, makeEllipsoid,
  makeBox, makeVertex, makeOffset, makeBaseBox,
  makeCompound, weldShellsAndFaces, makeSolid
} from 'brepjs';

// 1D shapes (edges & wires)
makeLine(v1, v2): Edge
makeCircle(radius, center?, normal?): Edge
makeEllipse(major, minor, center?, normal?, xDir?): Result<Edge>
makeHelix(pitch, height, radius, center?, dir?, lefthand?): Wire
makeThreePointArc(v1, v2, v3): Edge
makeEllipseArc(major, minor, startAngle, endAngle, center?, normal?, xDir?): Result<Edge>
makeTangentArc(startPoint, startTangent, endPoint): Edge
makeBSplineApproximation(points, config?): Result<Edge>
makeBezierCurve(points): Result<Edge>
assembleWire(edgesOrWires): Result<Wire>

// 2D faces
makeFace(wire, holes?): Result<Face>
makeNonPlanarFace(wire): Result<Face>
makeNewFaceWithinFace(originFace, wire): Face
addHolesInFace(face, holes): Face
makePolygon(points): Result<Face>

// 3D solids
makeBox(corner1, corner2): Solid
makeSphere(radius): Solid
makeCylinder(radius, height, location?, direction?): Solid
makeCone(radius1, radius2, height, location?, direction?): Solid
makeTorus(majorRadius, minorRadius, location?, direction?): Solid
makeEllipsoid(a, b, c): Solid
makeBaseBox(x, y, z): Shape3D
makeSolid(facesOrShells): Result<Solid>

// Vertex
makeVertex(point): Vertex

// Compound & shell
makeCompound(shapes): Compound
weldShellsAndFaces(facesOrShells, ignoreType?): Result<Shell>
makeOffset(face, offset, tolerance?): Result<Shape3D>
```

## 2D Blueprints & Curves

The `Drawing` class supports 2D boolean operations and transformations:

```typescript
const plate = drawRectangle(100, 50);
const hole = drawCircle(10).translate(20, 0);   // Drawing.translate is still available
const withHole = plate.cut(hole);               // Drawing.cut is still available
const filleted = withHole.fillet(3);             // Drawing.fillet is still available
const svg = filleted.toSVG();
```

Functional Blueprint API:
```typescript
import {
  createBlueprint, blueprintBoundingBox, blueprintOrientation,
  translateBlueprint, rotateBlueprint, scaleBlueprint, mirrorBlueprint,
  stretchBlueprint, blueprintToSVGPathD, blueprintIsInside,
  sketchBlueprintOnPlane, sketchBlueprintOnFace
} from 'brepjs';

createBlueprint(curves): Blueprint
blueprintBoundingBox(bp): BoundingBox2d
blueprintOrientation(bp): 'clockwise' | 'counterClockwise'
translateBlueprint(bp, dx, dy): Blueprint
rotateBlueprint(bp, angle, center?): Blueprint
scaleBlueprint(bp, factor, center?): Blueprint
mirrorBlueprint(bp, dir, origin?, mode?): Blueprint
stretchBlueprint(bp, ratio, direction, origin?): Blueprint
blueprintToSVGPathD(bp): string
blueprintIsInside(bp, point): boolean
sketchBlueprintOnPlane(bp, plane?, origin?): Sketch
sketchBlueprintOnFace(bp, face, scaleMode?): Sketch
```

Blueprint construction helpers:
```typescript
import { polysidesBlueprint, roundedRectangleBlueprint, organiseBlueprints } from 'brepjs';

polysidesBlueprint(radius, sidesCount, sagitta?): Blueprint   // Regular polygon as a Blueprint (lower-level than drawPolysides)
roundedRectangleBlueprint(width, height, r?): Blueprint        // Rounded rect as Blueprint. r: number | {rx?, ry?}
organiseBlueprints(blueprints: Blueprint[]): Blueprints        // Group flat blueprints into compound blueprints with hole detection
```

Low-level Blueprint boolean operations (single blueprint → single blueprint):
```typescript
import { fuseBlueprints, cutBlueprints, intersectBlueprints } from 'brepjs';

fuseBlueprints(first: Blueprint, second: Blueprint): null | Blueprint | Blueprints
cutBlueprints(first: Blueprint, second: Blueprint): null | Blueprint | Blueprints
intersectBlueprints(first: Blueprint, second: Blueprint): null | Blueprint | Blueprints
```

2D Boolean (functional):
```typescript
import { fuseBlueprint2D, cutBlueprint2D, intersectBlueprint2D } from 'brepjs';
import { fuse2D, cut2D, intersect2D } from 'brepjs';

fuseBlueprint2D(a, b): Shape2D
cutBlueprint2D(base, tool): Shape2D
intersectBlueprint2D(a, b): Shape2D
fuse2D(first, second): Shape2D
cut2D(first, second): Shape2D
intersect2D(first, second): Shape2D
// Shape2D = Blueprint | Blueprints | CompoundBlueprint | null
```

2D Curve functions:
```typescript
import {
  reverseCurve, curve2dBoundingBox, curve2dFirstPoint, curve2dLastPoint,
  curve2dSplitAt, curve2dParameter, curve2dTangentAt, curve2dIsOnCurve, curve2dDistanceFrom
} from 'brepjs';
```

## Projection & Camera

Project 3D shapes to 2D for technical drawings:

```typescript
import { drawProjection, createCamera, cameraLookAt, unwrap } from 'brepjs';

// Quick projection from a named plane
const { visible, hidden } = drawProjection(shape, 'front');
const svg = visible.toSVG();

// Custom camera
const camera = unwrap(createCamera([100, 100, 100], [0, 0, -1]));
const lookingAt = unwrap(cameraLookAt(camera, [0, 0, 0]));
const projected = drawProjection(shape, lookingAt);
```

Camera API:
```typescript
import { createCamera, cameraLookAt, cameraFromPlane, projectEdges } from 'brepjs';

createCamera(position?, direction?, xAxis?): Result<Camera>
cameraLookAt(camera, target): Result<Camera>
cameraFromPlane(planeName): Result<Camera>
projectEdges(shape, camera, withHiddenLines?): { visible: Edge[], hidden: Edge[] }
```

Additional projection helpers:
```typescript
import { isProjectionPlane, makeProjectedEdges } from 'brepjs';

isProjectionPlane(plane): plane is ProjectionPlane  // Type guard for ProjectionPlane strings
makeProjectedEdges(shape, camera, withHiddenLines?): { visible: Edge[], hidden: Edge[] }  // HLR projection
```

## Text

Render text as 2D outlines (requires font loading):

```typescript
import { loadFont, getFont, drawText, sketchText, textBlueprints } from 'brepjs';

await loadFont('/fonts/Roboto-Regular.ttf', 'Roboto');

// 2D text drawing
const text2d = drawText('Hello', { fontSize: 20, fontFamily: 'Roboto' });

// 3D text (sketch on plane, ready to extrude)
const text3d = sketchText('Hello', { fontSize: 20, fontFamily: 'Roboto' }, { plane: 'XY' });

// Get raw blueprints
const bps = textBlueprints('Hello', { fontSize: 20, fontFamily: 'Roboto' });
```

## Assembly Tree

Build hierarchical assemblies with transforms:

```typescript
import {
  createAssemblyNode, addChild, removeChild, updateNode,
  findNode, walkAssembly, countNodes, collectShapes
} from 'brepjs';

const root = createAssemblyNode('Root');
const part = createAssemblyNode('Part', {
  shape: myShape,
  translate: [10, 0, 0],
  rotate: { angle: 45, axis: [0, 0, 1] },
  metadata: { material: 'steel' }
});

const assembly = addChild(root, part);
const updated = updateNode(assembly, { translate: [20, 0, 0] });
const found = findNode(assembly, 'Part');
walkAssembly(assembly, (node, depth) => console.log(node.name, depth));
const count = countNodes(assembly);
const shapes = collectShapes(assembly);
const pruned = removeChild(assembly, 'Part');
```

## Parametric History

Track modeling operations for undo/replay:

```typescript
import {
  createHistory, addStep, undoLast, findStep,
  getHistoryShape, stepCount, stepsFrom,
  registerShape, createRegistry, registerOperation,
  replayHistory, replayFrom, modifyStep
} from 'brepjs';

// Create history and register operations
let history = createHistory();
let registry = createRegistry();
registry = registerOperation(registry, 'extrude', (inputs, params) => {
  return sketchRectangle(params.w, params.h).extrude(params.depth);
});

// Add steps
history = registerShape(history, 'base', baseShape);
history = addStep(history, {
  id: 'step1', type: 'extrude',
  parameters: { w: 10, h: 10, depth: 20 },
  inputIds: ['base'], outputId: 'extruded'
}, resultShape);

// Undo, replay, modify
history = undoLast(history);
const replayed = replayHistory(history, registry);
const modified = modifyStep(history, 'step1', { depth: 30 }, registry);
```

## Meshing

Convert shapes to triangle meshes for rendering:

```typescript
import { meshShape, meshShapeEdges } from 'brepjs';

const mesh = meshShape(shape, { tolerance: 0.5, angularTolerance: 20, includeUVs: true });
// mesh.vertices: Float32Array    (flat xyz)
// mesh.triangles: Uint32Array    (triangle indices)
// mesh.normals: Float32Array     (flat normals)
// mesh.uvs: Float32Array         (UV coordinates when includeUVs: true)
// mesh.faceGroups: {start, count, faceId}[]

const edgeMesh = meshShapeEdges(shape, { tolerance: 0.5 });
// edgeMesh.lines: number[]
// edgeMesh.edgeGroups: {start, count, edgeId}[]

// Full meshShape options (with defaults):
// meshShape(shape, {
//   tolerance: 1e-3,          // linear deflection
//   angularTolerance: 0.1,    // angular deflection (radians)
//   skipNormals: false,       // omit normals from output
//   includeUVs: false,        // include UV coordinates per-vertex
//   cache: true,              // cache results (WeakMap by shape)
//   signal?: AbortSignal,     // abort between face iterations
// })
```

Mesh caching:
```typescript
import { clearMeshCache, createMeshCache } from 'brepjs';

clearMeshCache();                       // Clear global cache
const cache = createMeshCache();        // Create isolated cache
```

### Three.js Integration

```typescript
import { toBufferGeometryData, toLineGeometryData, toGroupedBufferGeometryData } from 'brepjs';

const bufferData = toBufferGeometryData(mesh);
// { position: Float32Array, normal: Float32Array, index: Uint32Array }

const lineData = toLineGeometryData(edgeMesh);
// { position: Float32Array }

const grouped = toGroupedBufferGeometryData(mesh);
// extends bufferData with: groups: [{start, count, materialIndex, faceId}]
```

## Memory Management

OCCT objects are allocated in WASM memory and must be cleaned up:

```typescript
import { withScope, localGC, createHandle, createOcHandle } from 'brepjs';

// Scope-based cleanup (preferred)
const result = withScope((scope) => {
  const a = scope.register(someOcctObject);
  // a is auto-deleted when scope ends
  return finalShape;  // returned value survives the scope
});

// Manual cleanup
const [register, cleanup] = localGC();
try {
  const shape = register(sketchCircle(10).extrude(20));
  // ... use shape ...
} finally {
  cleanup();
}

// Explicit handle management
const handle = createHandle(ocShape);     // ShapeHandle: { wrapped, disposed, [Symbol.dispose] }
const ocHandle = createOcHandle(ocObj);   // OcHandle<T>: { value, disposed, [Symbol.dispose] }
```

`gcWithScope()` returns a register function that ties cleanup to FinalizationRegistry (GC-based). `gcWithObject(obj)` registers objects on an existing object for lifecycle tracking. `withScope` / `localGC` are preferred for deterministic cleanup.

## Error Handling

Many operations return `Result<T, BrepError>`:

```typescript
import { ok, err, OK, isOk, isErr, unwrap, unwrapOr, unwrapOrElse, match, map, andThen, collect, tryCatch, pipeline } from 'brepjs';

// Construction
ok(value): Ok<T>
err(error): Err<E>
OK                                      // Pre-built Ok<undefined> for void success

// Type guards
isOk(result): result is Ok<T>
isErr(result): result is Err<E>

// Extraction
unwrap(result): T                       // throws on Err
unwrapOr(result, defaultValue): T
unwrapOrElse(result, fn): T
unwrapErr(result): E                    // throws on Ok

// Combinators
map(result, fn): Result<U, E>
mapErr(result, fn): Result<T, F>
andThen(result, fn): Result<U, E>       // flatMap alias
collect(results): Result<T[], E>        // All-or-nothing

// Pattern matching
match(result, { ok: fn, err: fn }): U

// Try-catch boundary
tryCatch(fn, mapError): Result<T, E>
tryCatchAsync(fn, mapError): Promise<Result<T, E>>

// Pipeline
pipeline(input).then(fn).then(fn).result  // Chain Result operations
```

BrepError structure:
```typescript
interface BrepError {
  kind: BrepErrorKind;    // 'OCCT_OPERATION' | 'VALIDATION' | 'TYPE_CAST' | 'SKETCHER_STATE' | 'MODULE_INIT' | 'COMPUTATION' | 'IO' | 'QUERY'
  code: string;           // e.g. 'FUSE_FAILED', 'STEP_IMPORT_FAILED'
  message: string;
  cause?: unknown;
  metadata?: Record<string, unknown>;
}
```

Error constructors: `occtError(code, msg, cause?, meta?)`, `validationError(...)`, `typeCastError(...)`, `ioError(...)`, `computationError(...)`, `queryError(...)`, `sketcherStateError(...)`, `moduleInitError(...)`

## Worker Protocol

Off-main-thread CAD operations:

```typescript
import {
  createWorkerClient, createOperationRegistry, registerHandler, createWorkerHandler,
  createTaskQueue, enqueueTask, dequeueTask, pendingCount, isQueueEmpty, rejectAll,
  isInitRequest, isOperationRequest, isDisposeRequest, isSuccessResponse, isErrorResponse
} from 'brepjs';

// Client side
const client = createWorkerClient({ worker: myWorker, wasmUrl: '/wasm/oc.wasm' });
await client.init();
const result = await client.execute('fuse', [shape1Brep, shape2Brep], {});
client.dispose();

// Worker side
let registry = createOperationRegistry();
registry = registerHandler(registry, 'fuse', (shapesBrep, params) => {
  // shapesBrep: ReadonlyArray<string> — BREP-serialized input shapes
  // params: Readonly<Record<string, unknown>> — operation parameters
  // Must return { resultBrep?: string, resultData?: unknown }
  return { resultBrep: outputBrep };
});
createWorkerHandler(registry, async (wasmUrl) => { /* init WASM */ });
```

## Vec3 Math Utilities

```typescript
import {
  vecAdd, vecSub, vecScale, vecNegate,
  vecDot, vecCross, vecLength, vecLengthSq, vecDistance,
  vecNormalize, vecEquals, vecIsZero,
  vecAngle, vecProjectToPlane, vecRotate, vecRepr
} from 'brepjs';

vecAdd([1,0,0], [0,1,0]): Vec3         // [1, 1, 0]
vecSub(a, b): Vec3
vecScale(v, scalar): Vec3
vecNegate(v): Vec3
vecDot(a, b): number
vecCross(a, b): Vec3
vecLength(v): number
vecLengthSq(v): number
vecDistance(a, b): number
vecNormalize(v): Vec3
vecEquals(a, b, tolerance?): boolean
vecIsZero(v, tolerance?): boolean
vecAngle(a, b): number                 // radians
vecProjectToPlane(v, origin, normal): Vec3
vecRotate(v, axis, angleRad): Vec3
vecRepr(v): string                      // e.g. "(1.00, 2.00, 3.00)"
```

## Plane Operations

```typescript
import { createPlane, createNamedPlane, resolvePlane, translatePlane, pivotPlane } from 'brepjs';

createPlane(origin, xDirection?, normal?): Plane
createNamedPlane(name, origin?): Result<Plane>
resolvePlane(input, origin?): Plane     // PlaneName | Plane → Plane
translatePlane(plane, offset): Plane
pivotPlane(plane, angleDeg, axis?): Plane

// Additional helpers
makePlane(plane?, origin?): Plane       // From PlaneName + origin
makePlaneFromFace(face, originOnSurface?): Plane  // Derive plane from a face (useful for sketching on faces)
```

## Branded Shape Types (Functional API)

```typescript
import {
  castShape, getShapeKind,
  createVertex, createEdge, createWire, createFace, createShell, createSolid, createCompound,
  isVertex, isEdge, isWire, isFace, isShell, isSolid, isCompound, isShape3D, isShape1D
} from 'brepjs';

castShape(ocShape): AnyShape            // Auto-detect and wrap
getShapeKind(shape): ShapeKind          // 'vertex' | 'edge' | 'wire' | 'face' | 'shell' | 'solid' | 'compsolid' | 'compound'
isVertex(s): s is Vertex              // Type guards
// ... all type guards follow the same pattern
```

## OCCT Boundary Conversions

Low-level helpers for interop with raw OpenCascade objects:

```typescript
import { toOcVec, fromOcVec, fromOcPnt, fromOcDir, withOcVec, withOcPnt, withOcDir } from 'brepjs';

toOcVec(v): gp_Vec                      // Caller must delete()
fromOcVec(ocVec): Vec3                  // Extract tuple from gp_Vec
fromOcPnt(ocPnt): Vec3                  // Extract tuple from gp_Pnt
fromOcDir(ocDir): Vec3                  // Extract tuple from gp_Dir

// Scoped (auto-cleanup)
withOcVec(v, fn): T                     // fn receives gp_Vec, deleted after
withOcPnt(v, fn): T
withOcDir(v, fn): T
```

## Constants

- `DEG2RAD` — Multiply degrees to get radians
- `RAD2DEG` — Multiply radians to get degrees
- `HASH_CODE_MAX` — Maximum hash code value (2147483647)

## Types Reference

Key types used across the API:
- `Vec3`: `readonly [number, number, number]`
- `Vec2`: `readonly [number, number]`
- `PointInput`: `Vec3 | Vec2`
- `Point`: `[number, number, number]` (classic API)
- `Point2D`: `[number, number]`
- `Direction`: `Vec3 | 'X' | 'Y' | 'Z'`
- `Plane`: `{ origin: Vec3, xDir: Vec3, yDir: Vec3, zDir: Vec3 }`
- `PlaneName`: `'XY' | 'XZ' | 'YZ' | 'ZX' | 'YX' | 'ZY' | 'front' | 'back' | 'left' | 'right' | 'top' | 'bottom'`
- `PlaneInput`: `Plane | PlaneName`
- `ShapeKind`: `'vertex' | 'edge' | 'wire' | 'face' | 'shell' | 'solid' | 'compsolid' | 'compound'`
- `AnyShape`: Union of Vertex, Edge, Wire, Face, Shell, Solid, CompSolid, Compound
- `Shape3D`: Shell | Solid | CompSolid | Compound
- `Shape1D`: Edge | Wire
- `CurveType`: `'LINE' | 'CIRCLE' | 'ELLIPSE' | 'HYPERBOLA' | 'PARABOLA' | 'BEZIER_CURVE' | 'BSPLINE_CURVE' | 'OFFSET_CURVE' | 'OTHER_CURVE'`
- `SurfaceType`: `'PLANE' | 'CYLINDRE' | 'CONE' | 'SPHERE' | 'TORUS' | 'BEZIER_SURFACE' | 'BSPLINE_SURFACE' | 'REVOLUTION_SURFACE' | 'EXTRUSION_SURFACE' | 'OFFSET_SURFACE' | 'OTHER_SURFACE'`
- `Result<T, E>`: `Ok<T> | Err<E>` (default `E = BrepError`)
- `BrepError`: `{ kind: BrepErrorKind, code: string, message: string, cause?, metadata? }`
- `ShapeMesh`: `{ triangles: Uint32Array, vertices: Float32Array, normals: Float32Array, uvs: Float32Array, faceGroups }`
- `EdgeMesh`: `{ lines: number[], edgeGroups: {start, count, edgeId}[] }`
- `MeshOptions`: `{ tolerance?, angularTolerance?, signal? }` (meshShape also accepts `{ skipNormals?, includeUVs?, cache? }`)
- `BooleanOptions`: `{ optimisation?, simplify?, strategy?, signal? }`
- `Camera`: `{ position: Vec3, direction: Vec3, xAxis: Vec3, yAxis: Vec3 }`
- `ProjectionPlane`: `'XY' | 'XZ' | 'YZ' | 'YX' | 'ZX' | 'ZY' | 'front' | 'back' | 'top' | 'bottom' | 'left' | 'right'`
- `AssemblyNode`: `{ name, shape?, translate?, rotate?: { angle, axis? }, metadata?, children }`
- `ModelHistory`: `{ steps: ReadonlyArray<OperationStep>, shapes: ReadonlyMap<string, AnyShape> }`
- `OperationStep`: `{ id, type, parameters, inputIds, outputId, timestamp, metadata? }`
- `OperationFn`: `(inputs: AnyShape[], params: Record<string, unknown>) => AnyShape`
- `HistoryOperationRegistry`: `{ operations: ReadonlyMap<string, OperationFn> }`
- `HealingReport`: `{ isValid, alreadyValid, wiresHealed, facesHealed, solidHealed, steps, diagnostics }`
- `InterferenceResult`: `{ hasInterference, minDistance, pointOnShape1, pointOnShape2 }`
- `CurvatureResult`: `{ mean, gaussian, maxCurvature, minCurvature, maxDirection, minDirection }`
- `ShapeHandle`: `{ wrapped, disposed, [Symbol.dispose]() }`
- `Bounds3D`: `{ xMin, xMax, yMin, yMax, zMin, zMax }`
- `ShapeDescription`: `{ kind, faceCount, edgeCount, wireCount, vertexCount, valid, bounds }`

## Advanced Examples

### Flanged pipe fitting with loft, sweep, fillet, shell, and boolean

```typescript
import {
  initFromOC, gcWithScope, unwrap,
  sketchCircle, sketchRectangle, sketchRoundedRectangle,
  Sketcher, draw, drawCircle, drawRectangle,
  makeHelix, makeCylinder, makeSphere,
  exportSTEP, meshShape, exportGlb,
  faceFinder, edgeFinder, getFaces,
  fuseShape, cutShape, shellShape, filletShape,
  measureVolume, checkInterference, rotateShape,
} from 'brepjs';

// 1. Flanged pipe: main tube + two flanges, hollowed out
const pipe = gcWithScope(() => {
  // Main tube body
  const tube = makeCylinder(15, 100, [0, 0, 0], [0, 0, 1]);

  // Flanges at top and bottom
  const bottomFlange = makeCylinder(30, 5, [0, 0, 0], [0, 0, 1]);
  const topFlange = makeCylinder(30, 5, [0, 0, 95], [0, 0, 1]);

  // Fuse tube + flanges
  const step1 = unwrap(fuseShape(tube, bottomFlange));
  const body = unwrap(fuseShape(step1, topFlange));

  // Hollow out: remove top face, shell to 2mm wall thickness
  // parallelTo('XY') finds faces with Z-normal; atDistance selects the one at Z=100
  const shellFaces = faceFinder().parallelTo('XY').atDistance(100, [0, 0, 0]).findAll(body);
  const hollowed = unwrap(shellShape(body, shellFaces, 2));

  // Fillet the tube-to-flange transitions
  const filletEdges = edgeFinder().ofCurveType('CIRCLE').ofLength(2 * Math.PI * 15).findAll(hollowed);
  const filleted = unwrap(filletShape(hollowed, filletEdges, 3));

  // Bolt holes in each flange
  let result = filleted;
  for (let i = 0; i < 6; i++) {
    const angle = (360 / 6) * i;
    const hole = rotateShape(makeCylinder(3, 10, [22, 0, -2], [0, 0, 1]), angle, [0, 0, 0], [0, 0, 1]);
    result = unwrap(cutShape(result, hole));
  }
  // Same holes at top
  for (let i = 0; i < 6; i++) {
    const angle = (360 / 6) * i;
    const hole = rotateShape(makeCylinder(3, 10, [22, 0, 90], [0, 0, 1]), angle, [0, 0, 0], [0, 0, 1]);
    result = unwrap(cutShape(result, hole));
  }
  return result;
});

console.log('Volume:', measureVolume(pipe));
```

### Enclosure with drafted walls, snap-fit features, and embossed text

```typescript
import {
  gcWithScope, unwrap,
  sketchRoundedRectangle, sketchCircle, sketchRectangle,
  draw, drawText, loadFont, sketchText,
  makeCylinder, compoundSketchExtrude,
  fuseShape, cutShape, shellShape, filletShape,
  faceFinder, edgeFinder, translateShape,
} from 'brepjs';

await loadFont('/fonts/Roboto-Regular.ttf', 'Roboto');

const enclosure = gcWithScope(() => {
  // Base box with rounded corners — sketch.extrude() returns Shape3D directly (not Result)
  const box = sketchRoundedRectangle(80, 50, 5).extrude(30);

  // Shell: remove top face
  // parallelTo accepts StandardPlane strings ('XY', 'XZ', 'YZ') or Plane objects
  const shellFaces = faceFinder().parallelTo('XY').findAll(box);
  const shelled = unwrap(shellShape(box, shellFaces, 2));

  // Fillet all vertical edges
  const vertEdges = edgeFinder().inDirection([0, 0, 1]).findAll(shelled);
  const filleted = unwrap(filletShape(shelled, vertEdges, 1));

  // Mounting bosses: 4 cylinders at corners inside the box
  const bossPositions: [number, number][] = [[30, 18], [-30, 18], [30, -18], [-30, -18]];
  let result = filleted;
  for (const [x, y] of bossPositions) {
    const boss = makeCylinder(3, 25, [x, y, 2], [0, 0, 1]);
    const hole = makeCylinder(1.2, 25, [x, y, 2], [0, 0, 1]);
    result = unwrap(cutShape(unwrap(fuseShape(result, boss)), hole));
  }

  // Ventilation slots on side face
  for (let i = -2; i <= 2; i++) {
    const slot = translateShape(
      sketchRoundedRectangle(1.5, 10, 0.5, { plane: 'XZ' }).extrude(5),
      [0, -27, 15 + i * 3]
    );
    result = unwrap(cutShape(result, slot));
  }

  // Embossed text on top — text produces CompoundSketch, use compoundSketchExtrude
  const textSketch = sketchText('brepjs', { fontSize: 8, fontFamily: 'Roboto' }, { plane: 'XY', origin: 30 });
  const textSolid = compoundSketchExtrude(textSketch, 1);
  result = unwrap(fuseShape(result, textSolid));

  return result;
});
```

### Parametric spring with sweep and interference check

```typescript
import {
  gcWithScope, unwrap,
  sketchCircle, sketchHelix,
  Sketcher, makeHelix, makeCylinder,
  fuseShape, checkInterference,
  measureLength, describeShape,
  pipe, translateShape,
} from 'brepjs';

const spring = gcWithScope(() => {
  // Helix spine: pitch=8, height=60, radius=20
  const helixSketch = sketchHelix(8, 60, 20);

  // Sweep a circular cross-section along the helix
  const coil = helixSketch.sweepSketch((plane, origin) =>
    new Sketcher(plane).movePointerTo([-1.5, 0]).sagittaArc(3, 0, 1.5).sagittaArc(-3, 0, 1.5).close()
  );

  // Flat ends: cylinders at top and bottom
  const bottomEnd = makeCylinder(20, 2, [0, 0, -2], [0, 0, 1]);
  const topEnd = makeCylinder(20, 2, [0, 0, 60], [0, 0, 1]);

  return unwrap(fuseShape(unwrap(fuseShape(coil, bottomEnd)), topEnd));
});

// Check if spring fits inside a housing cylinder
const housing = makeCylinder(25, 70, [0, 0, -5], [0, 0, 1]);
const interference = unwrap(checkInterference(spring, housing));
console.log('Fits:', !interference.hasInterference, 'Gap:', interference.minDistance);

// Use pipe API for quick transforms
const movedSpring = pipe(spring).translate([100, 0, 0]).rotate(90, [0, 0, 0], [0, 1, 0]).done();
```

### Multi-format export with materials

```typescript
import {
  meshShape, exportGlb, exportOBJ, exportThreeMF, exportDXF,
  drawProjection, exportSTEP, exportAssemblySTEP,
  toBufferGeometryData, toGroupedBufferGeometryData,
} from 'brepjs';

// Mesh the shape for rendering
const mesh = meshShape(part, { tolerance: 0.1, angularTolerance: 15, includeUVs: true });

// glTF with per-face PBR materials
const materials = new Map();
for (const group of mesh.faceGroups) {
  materials.set(group.faceId, {
    name: `face_${group.faceId}`,
    baseColor: [0.7, 0.7, 0.8, 1.0],
    metallic: 0.8,
    roughness: 0.3,
  });
}
const glb = exportGlb(mesh, { materials });

// 3MF for 3D printing
const threemf = exportThreeMF(mesh, { name: 'MyPart', unit: 'millimeter' });

// OBJ for compatibility
const obj = exportOBJ(mesh);

// STEP with assembly structure and colors
const step = exportAssemblySTEP(
  [
    { shape: body, color: '#336699', name: 'Body' },
    { shape: lid, color: '#996633', name: 'Lid', alpha: 0.8 },
  ],
  { unit: 'millimeter' }
);

// 2D projection → DXF for laser cutting
const { visible } = drawProjection(part, 'top');
const dxf = exportDXF([
  { type: 'POLYLINE', points: [[0,0], [100,0], [100,50], [0,50]], closed: true, layer: 'outline' },
], { layer: '0', curveSegments: 64 });

// Three.js integration
const bufferData = toGroupedBufferGeometryData(mesh);
// Use bufferData.position, .normal, .index, .groups with THREE.BufferGeometry
```

### Functional API: immutable pipeline with healing

```typescript
import {
  pipe, unwrap,
  extrudeFace, makeFace, assembleWire, makeLine, makeCircle,
  fuseShape, cutShape, filletShape, shellShape,
  getEdges, getFaces, edgeFinder, faceFinder,
  autoHeal, isShapeValid, describeShape,
  translateShape, rotateShape, linearPattern,
  meshShape, exportGlb,
} from 'brepjs';

// Build with functional API (no classes, all immutable operations)
const base = extrudeFace(
  unwrap(makeFace(unwrap(assembleWire([
    makeLine([0,0,0], [40,0,0]),
    makeLine([40,0,0], [40,30,0]),
    makeLine([40,30,0], [0,30,0]),
    makeLine([0,30,0], [0,0,0]),
  ])))),
  [0, 0, 20]
);

// Find top face and cut mounting holes
const topFaces = faceFinder().inDirection('Z').findAll(base);
const holeFace = unwrap(makeFace(makeCircle(3, [10, 15, 20])));
const hole1 = extrudeFace(holeFace, [0, 0, -25]);
const withHoles = unwrap(cutShape(base, hole1));

// Fillet just the top edges
const topEdges = edgeFinder().atDistance(20, [20, 15, 0]).findAll(withHoles);
const filleted = unwrap(filletShape(withHoles, topEdges, 2));

// Shell it out
const shellFaces = faceFinder().inDirection([0, 0, 1]).findAll(filleted);
const shelled = unwrap(shellShape(filleted, shellFaces, 1.5));

// Validate and heal
if (!isShapeValid(shelled)) {
  const { shape: healed, report } = unwrap(autoHeal(shelled));
  console.log('Healed:', report.steps);
}

// Describe the result
const desc = describeShape(shelled);
console.log(`${desc.kind}: ${desc.faceCount} faces, ${desc.edgeCount} edges, valid: ${desc.valid}`);
```
